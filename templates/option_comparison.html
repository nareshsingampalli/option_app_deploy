<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Option Chain Visualizer</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-container {
            display: flex;
            flex: 1;
            height: 100%;
            overflow: hidden;
        }

        /* Sidebar Styles */
        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #e0e0e0;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
        }

        .sidebar h2 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 34px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider-toggle {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 34px;
        }

        .slider-toggle:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider-toggle {
            background-color: #2196F3;
        }

        input:focus+.slider-toggle {
            box-shadow: 0 0 1px #2196F3;
        }

        input:checked+.slider-toggle:before {
            -webkit-transform: translateX(14px);
            -ms-transform: translateX(14px);
            transform: translateX(14px);
        }

        .live-label {
            font-size: 12px;
            color: #666;
            margin-right: 5px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            cursor: pointer;
        }

        .scrollable-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 5px;
            border-radius: 4px;
        }

        .btn-group {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }

        .btn {
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .btn:hover {
            background: #e0e0e0;
        }

        /* Main Content Styles */
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chart-container {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            min-height: 400px;
        }

        .chart-header {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #444;
            border-left: 4px solid #007bff;
            padding-left: 10px;
        }

        /* Loading Overlay */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: #666;
            z-index: 1000;
        }

        @keyframes pulse {
            0% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.6;
            }
        }
    </style>
</head>

<body>
    <div id="loading">Loading Option Data...</div>

    <div class="app-container">
        <!-- Sidebar Controls -->
        <div class="sidebar">
            <div>
                <h2>
                    Controls
                    <div style="display:flex; align-items:center;">
                        <span class="live-label">Live</span>
                        <label class="switch">
                            <input type="checkbox" id="live-toggle" onchange="toggleLiveMode()">
                            <span class="slider-toggle"></span>
                        </label>
                    </div>
                </h2>

                <div class="control-group">
                    <label>Select Mode:</label>
                    <div class="btn-group" id="mode-toggle-group" style="margin-bottom: 10px;">
                        <button class="btn mode-btn active" onclick="setMode('NSE')" id="btn-nse"
                            style="flex:1; background:#007bff; color:white;">NSE (Nifty)</button>
                        <button class="btn mode-btn" onclick="setMode('MCX')" id="btn-mcx" style="flex:1;">MCX
                            (Crude)</button>
                    </div>
                </div>

                <div id="auth-error-container"
                    style="display:none; padding:10px; background:#ffebee; border:1px solid #ffcdd2; border-radius:4px; margin-bottom:10px;">
                    <div style="color:#d32f2f; font-size:12px; margin-bottom:5px;">Authentication Failed</div>
                    <button class="btn" style="width:100%; background:#d32f2f; color:white; border:none;"
                        onclick="refreshToken()">
                        Refresh Token & Retry
                    </button>
                </div>

                <div id="pending-indicator"
                    style="display:none; text-align:center; padding:5px; background:#fff3e0; border:1px solid #ffe0b2; border-radius:4px; margin-bottom:10px; font-size:12px; color:#e65100;">
                    <span style="animation: pulse 1.5s infinite;">‚è≥ Pending update...</span>
                </div>

                <div class="control-group">
                    <label for="date-picker">Select Date:</label>
                    <input type="date" id="date-picker" class="form-control"
                        style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div class="control-group">
                    <label for="time-slider">Spot Reference Time: <span id="time-display"
                            style="font-weight:bold; color:#007bff; margin-left:5px;">09:15</span></label>
                    <input type="range" id="time-slider" min="0" max="25" value="0" step="1" style="width: 100%;">
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666;">
                        <span>09:15</span>
                        <span>12:15</span>
                        <span>15:30</span>
                    </div>
                    <small style="color: #666; font-size: 11px;">Slide to change strike selection time</small>
                </div>
                <div class="control-group" id="auto-refresh-group" style="display:none; margin-top:5px;">
                    <label style="font-size: 12px; color: #666;">
                        <input type="checkbox" id="auto-refresh-cb"> Auto-Refresh (Live)
                    </label>
                </div>
                <div id="spot-price-display"
                    style="margin-top: 10px; font-weight: bold; color: #007bff; font-size: 16px;"></div>
                <div id="expiry-date-display" style="font-size: 14px; color: #555; margin-top: 5px;"></div>
                <div id="last-updated" style="font-size: 10px; color: #999; margin-top: 2px;"></div>
            </div>

            <div>
                <h2>Instruments</h2>
                <div class="btn-group">
                    <button class="btn" onclick="selectInstruments('all')">All</button>
                    <button class="btn" onclick="selectInstruments('ce')">All CE</button>
                    <button class="btn" onclick="selectInstruments('pe')">All PE</button>
                    <button class="btn" onclick="selectInstruments('none')">Clear</button>
                </div>
                <div class="scrollable-list" id="instrument-list">
                    <!-- Checkboxes populated via JS -->
                </div>
            </div>

            <div>
                <h2>Metrics (Criteria)</h2>
                <div class="control-group" id="metric-list">
                    <label><input type="checkbox" class="metric-cb" value="ltp" onchange="renderCharts()" checked>
                        LTP</label>
                    <label><input type="checkbox" class="metric-cb" value="change_in_ltp" onchange="renderCharts()">
                        Change in LTP</label>
                    <label><input type="checkbox" class="metric-cb" value="roc_oi" onchange="renderCharts()" checked>
                        ROC OI (%)</label>
                    <label><input type="checkbox" class="metric-cb" value="roc_volume" onchange="renderCharts()"> ROC
                        Volume (%)</label>
                    <label><input type="checkbox" class="metric-cb" value="roc_iv" onchange="renderCharts()"> ROC IV
                        (%)</label>
                    <label><input type="checkbox" class="metric-cb" value="coi_vol_ratio" onchange="renderCharts()">
                        COI/Vol Ratio</label>
                    <label><input type="checkbox" class="metric-cb" value="spot_price" onchange="renderCharts()"
                            checked> Spot Price</label>
                </div>
            </div>

            <button class="btn" style="width: 100%; padding: 10px; background: #007bff; color: white; border: none;"
                onclick="fetchData()">Fetch Data Now</button>
            <button class="btn"
                style="width: 100%; padding: 10px; margin-top: 10px; background: #28a745; color: white; border: none;"
                onclick="refreshToken()">Refresh Env & Token</button>
        </div>

        <!-- Main Chart Area -->
        <div class="main-content" id="charts-area">
            <!-- Charts will be injected here -->
        </div>
    </div>

    <script>
        let rawData = [];
        let uniqueSymbols = [];
        let currentMode = 'NSE'; // NSE or MCX

        function setMode(mode) {
            if (currentMode === mode) return;
            currentMode = mode;

            // Clear old state
            rawData = [];
            document.getElementById('instrument-list').innerHTML = '';
            document.getElementById('spot-price-display').textContent = '';
            document.getElementById('expiry-date-display').textContent = '';
            document.getElementById('last-updated').textContent = '';

            // Update UI buttons
            const nseBtn = document.getElementById('btn-nse');
            const mcxBtn = document.getElementById('btn-mcx');
            const slider = document.getElementById('time-slider');

            // Find labels
            const labels = slider.nextElementSibling.querySelectorAll('span');

            if (mode === 'NSE') {
                if (nseBtn) { nseBtn.style.background = '#007bff'; nseBtn.style.color = 'white'; }
                if (mcxBtn) { mcxBtn.style.background = '#f0f0f0'; mcxBtn.style.color = '#333'; }

                slider.max = 25; // 09:15 to 15:30 (15 min steps)
                if (labels.length >= 3) {
                    labels[0].textContent = '09:15';
                    labels[1].textContent = '12:15';
                    labels[2].textContent = '15:30';
                }
                metricLabels['spot_price'] = 'Spot Price (Nifty 50)';
            } else {
                if (mcxBtn) { mcxBtn.style.background = '#007bff'; mcxBtn.style.color = 'white'; }
                if (nseBtn) { nseBtn.style.background = '#f0f0f0'; nseBtn.style.color = '#333'; }

                slider.max = 29; // 09:00 to 23:30 (30 min steps)
                if (labels.length >= 3) {
                    labels[0].textContent = '09:00';
                    labels[1].textContent = '16:00';
                    labels[2].textContent = '23:30';
                }
                metricLabels['spot_price'] = 'Spot Price (Crude Oil)';
            }

            slider.value = 0;
            document.getElementById('time-display').textContent = sliderToTime(0);

            // Use debounced fetch for mode switches too
            debouncedFetch(isLiveMode ? 100 : 5000);
        }

        async function refreshToken() {
            try {
                const response = await fetch('/api/refresh-token', { method: 'POST' });
                const result = await response.json();
                if (response.ok) {
                    alert('Environment variables refreshed successfully!');
                    fetchData(); // Reload data after refresh
                } else {
                    alert('Failed to refresh: ' + result.error);
                }
            } catch (error) {
                alert('Error refreshing token: ' + error);
            }
        }

        const metricLabels = {
            'ltp': 'Last Traded Price',
            'change_in_ltp': 'Change in LTP',
            'roc_oi': 'Rate of Change in Open Interest (%)',
            'roc_volume': 'Rate of Change in Volume (%)',
            'roc_iv': 'Rate of Change in IV (%)',
            'coi_vol_ratio': 'Change in OI / Volume Ratio',
            'spot_price': 'Spot Price (Nifty 50)'
        };

        // Initialize Date Picker with today or default
        const datePicker = document.getElementById('date-picker');
        const timeSlider = document.getElementById('time-slider');
        const timeDisplay = document.getElementById('time-display');

        // Slider Logic
        function sliderToTime(val) {
            if (currentMode === 'NSE') {
                const startMinutes = 9 * 60 + 15; // 09:15 = 555
                const totalMinutes = startMinutes + (val * 15);
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            } else {
                // MCX: 30 min steps starting 09:00
                const startMinutes = 9 * 60; // 09:00
                const totalMinutes = startMinutes + (val * 30);
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            }
        }

        // Debounce: wait for user to stop interacting before fetching (non-live mode)
        let _fetchDebounceTimer = null;
        function debouncedFetch(delay = 5000) {
            const pending = document.getElementById('pending-indicator');
            if (pending) pending.style.display = 'block';

            if (isLiveMode) {
                // Live mode: force fetch to ensure we get data for current symbol
                if (pending) pending.style.display = 'none';
                fetchData();
                return;
            }
            clearTimeout(_fetchDebounceTimer);
            _fetchDebounceTimer = setTimeout(() => {
                if (pending) pending.style.display = 'none';
                fetchData();
            }, delay);
        }

        // Slider: update display on every tick (input), fetch only on release (change)
        timeSlider.addEventListener('input', () => {
            timeDisplay.textContent = sliderToTime(timeSlider.value);
            updateDynamicSpotPrice();
        });

        function updateDynamicSpotPrice() {
            if (!rawData || rawData.length === 0) return;
            const val = timeSlider.value;
            const targetTime = sliderToTime(val);

            // rawData date is "YYYY-MM-DD HH:MM:SS" or similar
            // We want to find the record closest to targetTime
            const match = rawData.find(r => r.date.includes(targetTime));
            if (match && match.spot_price) {
                document.getElementById('spot-price-display').textContent = `Spot Price: ${match.spot_price}`;
            }
        }

        timeSlider.addEventListener('change', () => {
            if (!isLiveMode) {
                debouncedFetch(5000); // 5 sec delay after release
            }
        });

        // Default to today so the time slider works for today's intraday data
        const todayStr = new Date().toISOString().split('T')[0];
        datePicker.max = todayStr;
        datePicker.value = todayStr;

        datePicker.addEventListener('change', () => {
            checkAutoRefresh();
            if (!isLiveMode) {
                debouncedFetch(5000); // Wait 5s on date change
            }
        });

        const autoRefreshCb = document.getElementById('auto-refresh-cb');
        let refreshInterval = null;
        let isLiveMode = false;

        function toggleLiveMode() {
            const toggle = document.getElementById('live-toggle');
            isLiveMode = toggle.checked;
            const datePicker = document.getElementById('date-picker');

            if (isLiveMode) {
                datePicker.disabled = true;
                const today = new Date().toISOString().split('T')[0];
                datePicker.value = today;

                // Force auto-refresh
                if (!autoRefreshCb.checked) {
                    autoRefreshCb.checked = true;
                }
                // 5 minutes = 300000 ms
                startAutoRefresh(300000);
                debouncedFetch(100);
            } else {
                datePicker.disabled = false;
                stopAutoRefresh();
                checkAutoRefresh();
            }
        }

        autoRefreshCb.addEventListener('change', () => {
            if (autoRefreshCb.checked) {
                startAutoRefresh(isLiveMode ? 300000 : 60000);
            } else {
                stopAutoRefresh();
            }
        });

        function checkAutoRefresh() {
            const date = datePicker.value;
            const today = new Date().toISOString().split('T')[0];
            const refreshGroup = document.getElementById('auto-refresh-group');

            if (date === today) {
                refreshGroup.style.display = 'flex';
                // Auto-enable for today
                if (!autoRefreshCb.checked) {
                    autoRefreshCb.checked = true;
                    startAutoRefresh(isLiveMode ? 300000 : 60000);
                }
            } else {
                refreshGroup.style.display = 'none';
                stopAutoRefresh();
                autoRefreshCb.checked = false;
            }
        }

        function startAutoRefresh(interval = 60000) {
            if (refreshInterval) clearInterval(refreshInterval);
            refreshInterval = setInterval(() => {
                console.log("Auto-refreshing...");
                fetchData(true); // silent refresh
            }, interval);
        }

        function stopAutoRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
        }

        // Fetch data on load
        // checkAutoRefresh(); // Check if today matches
        // fetchData();
        document.getElementById('loading').style.display = 'none'; // Hide loading initially

        function fetchData(silent = false) {
            clearTimeout(_fetchDebounceTimer);
            const pending = document.getElementById('pending-indicator');
            if (pending) pending.style.display = 'none';

            const date = datePicker.value;
            if (!date) return;

            // Get time from slider
            const sliderVal = document.getElementById('time-slider').value;
            const time = sliderToTime(sliderVal);

            const updateBtn = document.querySelector('button[onclick="fetchData()"]');
            if (updateBtn) {
                updateBtn.disabled = true;
                updateBtn.textContent = "Fetching Data...";
            }

            if (!silent) {
                document.getElementById('loading').style.display = 'flex';
                let loadingText = `Loading ${currentMode} data for ${date}`;
                if (isLiveMode) loadingText = `Loading LIVE ${currentMode} data (Selected Date: ${date} overridden)`;
                else if (time) loadingText += ` at ${time}`;
                loadingText += `... (May take time if fetching new data)`;
                document.getElementById('loading').textContent = loadingText;
            }

            let url = `/api/option-data?date=${date}&symbol=${currentMode}`;
            if (time) url += `&time=${time}`;
            if (isLiveMode) url += `&live=true`;

            fetch(url)
                .then(response => {
                    if (!response.ok) throw new Error('Network response was not ok');
                    return response.json();
                })
                .then(data => {
                    if (data.error) {
                        document.getElementById('loading').style.display = 'none';
                        if (!silent) {
                            alert(data.error);
                            if (data.error.includes("UPSTOX_ACCESS_TOKEN") || data.error.toLowerCase().includes("unauthorized")) {
                                document.getElementById('auth-error-container').style.display = 'block';
                            }
                        }

                        // If meta is present in error, display spot price at least
                        if (data.meta) {
                            if (data.meta.spot_price) {
                                document.getElementById('spot-price-display').textContent = `Spot Price: ${data.meta.spot_price}`;
                            }
                            if (data.meta.expired_contracts) {
                                document.getElementById('expiry-date-display').textContent = 'Expired Contracts Unavailable';
                                document.getElementById('expiry-date-display').style.color = 'red';
                            } else {
                                document.getElementById('expiry-date-display').textContent = '';
                            }
                        }
                        return;
                    } else {
                        document.getElementById('expiry-date-display').style.color = '#555';
                    }

                    // Handle new structure { data: [...], meta: {...} }
                    let records = [];
                    if (Array.isArray(data)) {
                        records = data; // Backward compatibility
                    } else if (data.data) {
                        records = data.data;
                        if (data.meta) {
                            if (data.meta.spot_price) {
                                document.getElementById('spot-price-display').textContent = `Spot Price: ${data.meta.spot_price}`;
                            }
                            if (data.meta.expiry_date) {
                                document.getElementById('expiry-date-display').textContent = `Expiry: ${data.meta.expiry_date}`;
                            } else {
                                document.getElementById('expiry-date-display').textContent = '';
                            }
                            if (data.meta.fetched_at) {
                                const fetchedTime = new Date(data.meta.fetched_at).toLocaleTimeString();
                                document.getElementById('last-updated').textContent = `Last Updated: ${fetchedTime}`;
                            }
                        } else {
                            document.getElementById('spot-price-display').textContent = '';
                            document.getElementById('expiry-date-display').textContent = '';
                            document.getElementById('last-updated').textContent = '';
                        }
                    }

                    rawData = records;
                    // Only re-init controls if not silent (or if structure changed significantly?)
                    // For live updates, we probably want to keep current selections.
                    // But if instruments change (e.g. new strikes added?), we might need to update list.
                    if (!silent) {
                        initializeControls(false); // full reset
                    } else {
                        updateControlsMerge(); // smart merge
                    }

                    updateDynamicSpotPrice(); // Update sidebar spot price from data
                    document.getElementById('loading').style.display = 'none';
                    renderCharts();
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                    document.getElementById('loading').style.display = 'none';
                    if (!silent) alert('Error loading data. Check console.');
                });
        }

        function initializeControls() {
            const symbolSet = new Set(rawData.map(row => row.symbol));
            uniqueSymbols = Array.from(symbolSet).sort();

            const listContainer = document.getElementById('instrument-list');
            listContainer.innerHTML = '';

            uniqueSymbols.forEach(sym => {
                listContainer.appendChild(makeInstrumentRow(sym, true));
            });
        }

        function makeInstrumentRow(sym, checked) {
            const div = document.createElement('div');
            div.className = 'control-group';
            div.dataset.symbol = sym;
            div.innerHTML = `<label><input type="checkbox" class="instrument-cb" value="${sym}" ${checked ? 'checked' : ''} onchange="renderCharts()"> ${sym}</label>`;
            return div;
        }

        function updateControlsMerge() {
            const newSymbols = new Set(rawData.map(row => row.symbol));
            const listContainer = document.getElementById('instrument-list');

            // Save current checkbox states
            const states = {};
            document.querySelectorAll('.instrument-cb').forEach(cb => {
                states[cb.value] = cb.checked;
            });

            // Remove rows for symbols no longer in data
            const existing = listContainer.querySelectorAll('[data-symbol]');
            existing.forEach(row => {
                if (!newSymbols.has(row.dataset.symbol)) {
                    row.remove();
                    console.log(`Removed strike: ${row.dataset.symbol}`);
                }
            });

            // Add rows for new symbols not yet in the list
            const existingSymbols = new Set(
                Array.from(listContainer.querySelectorAll('[data-symbol]')).map(r => r.dataset.symbol)
            );
            const sortedNew = Array.from(newSymbols).sort();
            sortedNew.forEach(sym => {
                if (!existingSymbols.has(sym)) {
                    // Insert in sorted order
                    const newRow = makeInstrumentRow(sym, true); // new strikes default checked
                    let inserted = false;
                    const rows = listContainer.querySelectorAll('[data-symbol]');
                    for (const row of rows) {
                        if (sym < row.dataset.symbol) {
                            listContainer.insertBefore(newRow, row);
                            inserted = true;
                            break;
                        }
                    }
                    if (!inserted) listContainer.appendChild(newRow);
                    console.log(`Added new strike: ${sym}`);
                }
            });

            // Restore previous checkbox states for unchanged symbols
            document.querySelectorAll('.instrument-cb').forEach(cb => {
                if (cb.value in states) cb.checked = states[cb.value];
            });

            uniqueSymbols = sortedNew;
        }

        function selectInstruments(type) {
            const checkboxes = document.querySelectorAll('.instrument-cb');
            checkboxes.forEach(cb => {
                if (type === 'all') cb.checked = true;
                else if (type === 'none') cb.checked = false;
                else if (type === 'ce') cb.checked = cb.value.includes('CE');
                else if (type === 'pe') cb.checked = cb.value.includes('PE');
            });
            renderCharts();
        }

        function renderCharts() {
            const chartsArea = document.getElementById('charts-area');
            chartsArea.innerHTML = '';

            // Get selected instruments
            const selectedInstruments = Array.from(document.querySelectorAll('.instrument-cb:checked')).map(cb => cb.value);

            // Get selected metrics
            const selectedMetrics = Array.from(document.querySelectorAll('.metric-cb:checked')).map(cb => cb.value);

            if (selectedInstruments.length === 0) {
                chartsArea.innerHTML = '<div style="text-align:center; color:#666;">No instruments selected.</div>';
                return;
            }

            if (selectedMetrics.length === 0) {
                chartsArea.innerHTML = '<div style="text-align:center; color:#666;">No metrics selected.</div>';
                return;
            }

            // Prepare data grouped by symbol
            const groupedData = {};

            rawData.forEach(row => {
                if (selectedInstruments.includes(row.symbol)) {
                    if (!groupedData[row.symbol]) {
                        groupedData[row.symbol] = { x: [], rowData: [] };
                    }
                    groupedData[row.symbol].x.push(row.date);
                    groupedData[row.symbol].rowData.push(row);
                }
            });

            // Generate a chart for EACH selected metric
            selectedMetrics.forEach(metric => {
                const chartDiv = document.createElement('div');
                chartDiv.className = 'chart-container';
                const chartId = `chart-${metric}`;
                chartDiv.innerHTML = `<div class="chart-header">${metricLabels[metric]}</div><div id="${chartId}"></div>`;
                chartsArea.appendChild(chartDiv);

                const traces = [];

                if (metric === 'spot_price') {
                    // For Spot Price, we only need ONE trace (the index) 
                    // since all symbols share the same spot_price data points
                    const firstSym = selectedInstruments[0];
                    if (groupedData[firstSym]) {
                        traces.push({
                            x: groupedData[firstSym].x,
                            y: groupedData[firstSym].rowData.map(r => r[metric]),
                            mode: 'lines',
                            name: currentMode === 'NSE' ? 'Nifty 50 Index' : 'Crude Oil Index',
                            line: {
                                width: 3,
                                color: '#007bff'
                            }
                        });
                    }
                } else {
                    selectedInstruments.forEach(symbol => {
                        if (!groupedData[symbol]) return;

                        const isCE = symbol.includes('CE');
                        const isPE = symbol.includes('PE');

                        // Dynamic Color Generation
                        // CE = Green hues, PE = Red hues
                        let color;
                        if (isCE) {
                            // Generate varied greens
                            // Use symbol hash to pick a stable variation
                            let hash = 0;
                            for (let i = 0; i < symbol.length; i++) {
                                hash = symbol.charCodeAt(i) + ((hash << 5) - hash);
                            }
                            const lightness = 25 + (Math.abs(hash) % 40); // 25% to 65% lightness
                            color = `hsl(120, 100%, ${lightness}%)`;
                        } else if (isPE) {
                            // Generate varied reds
                            let hash = 0;
                            for (let i = 0; i < symbol.length; i++) {
                                hash = symbol.charCodeAt(i) + ((hash << 5) - hash);
                            }
                            const lightness = 35 + (Math.abs(hash) % 30); // 35% to 65% lightness
                            color = `hsl(0, 100%, ${lightness}%)`;
                        } else {
                            color = '#888888';
                        }

                        traces.push({
                            x: groupedData[symbol].x,
                            y: groupedData[symbol].rowData.map(r => r[metric]),
                            mode: 'lines',
                            name: symbol,
                            line: {
                                dash: isPE ? 'dash' : 'solid',
                                width: 2,
                                color: color
                            }
                        });
                    });
                }

                const layout = {
                    margin: { t: 20, r: 20, l: 50, b: 40 },
                    height: 400,
                    xaxis: { title: 'Time' },
                    yaxis: { title: metricLabels[metric] },
                    hovermode: 'x unified',
                    showlegend: true,
                    legend: { orientation: 'h', y: -0.2 }
                };

                Plotly.newPlot(chartId, traces, layout);
            });
        }

        function refreshToken() {
            const btn = document.querySelector('#auth-error-container button');
            const originalText = btn.textContent;
            btn.textContent = 'Refreshing...';
            btn.disabled = true;

            fetch('/api/refresh-token', { method: 'POST' })
                .then(r => r.json())
                .then(data => {
                    if (data.error) {
                        alert('Refresh failed: ' + data.error);
                        btn.textContent = originalText;
                        btn.disabled = false;
                    } else {
                        alert('Token refreshed! Retrying data fetch...');
                        document.getElementById('auth-error-container').style.display = 'none';
                        fetchData(); // Retry fetch
                    }
                })
                .catch(e => {
                    alert('Network error refreshing token');
                    btn.textContent = originalText;
                    btn.disabled = false;
                });
        }
    </script>
</body>

</html>