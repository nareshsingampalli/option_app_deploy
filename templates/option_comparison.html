<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Option Chain Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-container {
            display: flex;
            flex: 1;
            height: 100%;
            overflow: hidden;
        }

        /* Sidebar Styles */
        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #e0e0e0;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
        }

        .sidebar h2 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 34px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider-toggle {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 34px;
        }

        .slider-toggle:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider-toggle {
            background-color: #2196F3;
        }

        input:focus+.slider-toggle {
            box-shadow: 0 0 1px #2196F3;
        }

        input:checked+.slider-toggle:before {
            -webkit-transform: translateX(14px);
            -ms-transform: translateX(14px);
            transform: translateX(14px);
        }

        .live-label {
            font-size: 12px;
            color: #666;
            margin-right: 5px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            cursor: pointer;
        }

        .scrollable-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 5px;
            border-radius: 4px;
        }

        .btn-group {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }

        .btn {
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .btn:hover {
            background: #e0e0e0;
        }

        /* Main Content Styles */
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chart-container {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            min-height: 400px;
        }

        .chart-header {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #444;
            border-left: 4px solid #007bff;
            padding-left: 10px;
        }

        /* Loading Overlay */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: #666;
            z-index: 1000;
        }

        @keyframes pulse {
            0% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.6;
            }
        }
    </style>
</head>

<body>
    <div id="loading">Loading Option Data...</div>

    <div class="app-container">
        <!-- Sidebar Controls -->
        <div class="sidebar">
            <div>
                <h2>
                    Controls
                    <div style="display:flex; align-items:center;">
                        <span class="live-label">Live</span>
                        <label class="switch">
                            <input type="checkbox" id="live-toggle" onchange="toggleLiveMode()">
                            <span class="slider-toggle"></span>
                        </label>
                    </div>
                </h2>

                <div class="control-group">
                    <label>Select Mode:</label>
                    <div class="btn-group" id="mode-toggle-group" style="margin-bottom: 10px;">
                        <button class="btn mode-btn active" onclick="setMode('NSE')" id="btn-nse"
                            style="flex:1; background:#007bff; color:white;">NSE (Nifty)</button>
                        <button class="btn mode-btn" onclick="setMode('MCX')" id="btn-mcx" style="flex:1;">MCX
                            (Crude)</button>
                    </div>
                </div>

                <div id="auth-error-container"
                    style="display:none; padding:10px; background:#ffebee; border:1px solid #ffcdd2; border-radius:4px; margin-bottom:10px;">
                    <div style="color:#d32f2f; font-size:12px; margin-bottom:5px;">Authentication Failed</div>
                    <button class="btn" style="width:100%; background:#d32f2f; color:white; border:none;"
                        onclick="refreshToken()">
                        Refresh Token & Retry
                    </button>
                </div>

                <div id="pending-indicator"
                    style="display:none; text-align:center; padding:5px; background:#fff3e0; border:1px solid #ffe0b2; border-radius:4px; margin-bottom:10px; font-size:12px; color:#e65100;">
                    <span style="animation: pulse 1.5s infinite;">⏳ Pending update...</span>
                </div>

                <div class="control-group">
                    <label for="date-picker">Select Date:</label>
                    <input type="date" id="date-picker" class="form-control"
                        style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div class="control-group">
                    <label for="time-slider">Spot Reference Time: <span id="time-display"
                            style="font-weight:bold; color:#007bff; margin-left:5px;">09:15</span></label>
                    <input type="range" id="time-slider" min="0" max="25" value="0" step="1" style="width: 100%;">
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666;">
                        <span>09:15</span>
                        <span>12:15</span>
                        <span>15:30</span>
                    </div>
                    <small style="color: #666; font-size: 11px;">Slide to change strike selection time</small>
                </div>
                <div class="control-group" id="auto-refresh-group" style="display:none; margin-top:5px;">
                    <label style="font-size: 12px; color: #666;">
                        <input type="checkbox" id="auto-refresh-cb"> Auto-Refresh (Live)
                    </label>
                </div>
                <div id="spot-price-display"
                    style="margin-top: 10px; font-weight: bold; color: #007bff; font-size: 16px;"></div>
                <div id="expiry-date-display" style="font-size: 14px; color: #555; margin-top: 5px;"></div>
                <div id="last-updated" style="font-size: 10px; color: #999; margin-top: 2px;"></div>
            </div>

            <div>
                <h2>Instruments</h2>
                <div class="btn-group">
                    <button class="btn" onclick="selectInstruments('all')">All</button>
                    <button class="btn" onclick="selectInstruments('ce')">All CE</button>
                    <button class="btn" onclick="selectInstruments('pe')">All PE</button>
                    <button class="btn" onclick="selectInstruments('none')">Clear</button>
                </div>
                <div class="scrollable-list" id="instrument-list">
                    <!-- Checkboxes populated via JS -->
                </div>
            </div>

            <div>
                <h2>Metrics (Criteria)</h2>
                <div class="control-group" id="metric-list">
                    <label><input type="checkbox" class="metric-cb" value="ltp" checked>
                        LTP</label>
                    <label><input type="checkbox" class="metric-cb" value="change_in_ltp">
                        Change in LTP</label>
                    <label><input type="checkbox" class="metric-cb" value="roc_oi" checked>
                        ROC OI (%)</label>
                    <label><input type="checkbox" class="metric-cb" value="roc_volume"> ROC
                        Volume (%)</label>
                    <label><input type="checkbox" class="metric-cb" value="roc_iv"> ROC IV
                        (%)</label>
                    <label><input type="checkbox" class="metric-cb" value="coi_vol_ratio">
                        COI/Vol Ratio</label>
                    <label><input type="checkbox" class="metric-cb" value="spot_price" checked> Spot Price</label>
                </div>
            </div>

            <button class="btn" style="width: 100%; padding: 10px; background: #007bff; color: white; border: none;"
                onclick="fetchData()">Update Charts</button>
            <button class="btn"
                style="width: 100%; padding: 10px; margin-top: 10px; background: #28a745; color: white; border: none;"
                onclick="refreshToken()">Refresh Env & Token</button>
        </div>

        <!-- Main Chart Area -->
        <div class="main-content" id="charts-area">
            <!-- Charts will be injected here -->
        </div>
    </div>

    <script>
        let rawData = [];
        let uniqueSymbols = [];
        let currentMode = 'NSE'; // NSE or MCX

        function setMode(mode) {
            if (currentMode === mode) return;
            currentMode = mode;

            // Clear old state
            rawData = [];
            document.getElementById('instrument-list').innerHTML = '';
            document.getElementById('spot-price-display').textContent = '';
            document.getElementById('expiry-date-display').textContent = '';
            document.getElementById('last-updated').textContent = '';

            // Update UI buttons
            const nseBtn = document.getElementById('btn-nse');
            const mcxBtn = document.getElementById('btn-mcx');
            const slider = document.getElementById('time-slider');

            // Find labels
            const labels = slider.nextElementSibling.querySelectorAll('span');

            if (mode === 'NSE') {
                if (nseBtn) { nseBtn.style.background = '#007bff'; nseBtn.style.color = 'white'; }
                if (mcxBtn) { mcxBtn.style.background = '#f0f0f0'; mcxBtn.style.color = '#333'; }

                slider.max = 25; // 09:15 to 15:30 (15 min steps)
                if (labels.length >= 3) {
                    labels[0].textContent = '09:15';
                    labels[1].textContent = '12:15';
                    labels[2].textContent = '15:30';
                }
                metricLabels['spot_price'] = 'Spot Price (Nifty 50)';
            } else {
                if (mcxBtn) { mcxBtn.style.background = '#007bff'; mcxBtn.style.color = 'white'; }
                if (nseBtn) { nseBtn.style.background = '#f0f0f0'; nseBtn.style.color = '#333'; }

                slider.max = 29; // 09:00 to 23:30 (30 min steps)
                if (labels.length >= 3) {
                    labels[0].textContent = '09:00';
                    labels[1].textContent = '16:00';
                    labels[2].textContent = '23:30';
                }
                metricLabels['spot_price'] = 'Spot Price (Crude Oil)';
            }

            slider.value = 0;
            document.getElementById('time-display').textContent = sliderToTime(0);

            // Use debounced fetch for mode switches too
            debouncedFetch(500);
        }

        function formatSymbol(sym) {
            if (!sym) return '';

            // NSE Pattern: NIFTY2630225350CE
            if (sym.includes('NIFTY')) {
                const typeMatch = sym.match(/(CE|PE)$/);
                if (!typeMatch) return sym;
                const typeStr = typeMatch[1];
                const rest = sym.slice(0, -2);
                const strikeMatch = rest.match(/(\d+)$/);
                if (strikeMatch) {
                    return `${strikeMatch[1]} ${typeStr}`;
                }
            }

            // MCX Pattern: CRUDEOIL 5850 CE 17 MAR 26
            if (sym.includes('CRUDEOIL')) {
                const parts = sym.split(' ');
                if (parts.length >= 3) {
                    return `${parts[1]} ${parts[2]}`;
                }
            }

            return sym;
        }

        async function refreshToken() {
            try {
                const response = await fetch('/api/refresh-token', { method: 'POST' });
                const result = await response.json();
                if (response.ok) {
                    alert('Environment variables refreshed successfully!');
                    fetchData(); // Reload data after refresh
                } else {
                    alert('Failed to refresh: ' + result.error);
                }
            } catch (error) {
                alert('Error refreshing token: ' + error);
            }
        }

        const metricLabels = {
            'ltp': 'Last Traded Price',
            'change_in_ltp': 'Change in LTP',
            'roc_oi': 'Rate of Change in Open Interest (%)',
            'roc_volume': 'Rate of Change in Volume (%)',
            'roc_iv': 'Rate of Change in IV (%)',
            'coi_vol_ratio': 'Change in OI / Volume Ratio',
            'spot_price': 'Spot Price (Nifty 50)'
        };

        // Initialize Date Picker with today or default
        const datePicker = document.getElementById('date-picker');
        const timeSlider = document.getElementById('time-slider');
        const timeDisplay = document.getElementById('time-display');

        // Slider Logic
        function sliderToTime(val) {
            if (currentMode === 'NSE') {
                const startMinutes = 9 * 60 + 15; // 09:15 = 555
                const totalMinutes = startMinutes + (val * 15);
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            } else {
                // MCX: 30 min steps starting 09:00
                const startMinutes = 9 * 60; // 09:00
                const totalMinutes = startMinutes + (val * 30);
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            }
        }

        // Debounce: wait for user to stop interacting before fetching (non-live mode)
        let _fetchDebounceTimer = null;
        function debouncedFetch(delay = 5000) {
            const pending = document.getElementById('pending-indicator');
            if (pending) pending.style.display = 'block';

            if (isLiveMode) {
                // Live mode: force fetch to ensure we get data for current symbol
                if (pending) pending.style.display = 'none';
                fetchData();
                return;
            }
            clearTimeout(_fetchDebounceTimer);
            _fetchDebounceTimer = setTimeout(() => {
                if (pending) pending.style.display = 'none';
                fetchData();
            }, delay);
        }

        // Slider: update display on every tick (input), fetch only on release (change)
        timeSlider.addEventListener('input', () => {
            timeDisplay.textContent = sliderToTime(timeSlider.value);
            updateDynamicSpotPrice();
        });

        function updateDynamicSpotPrice() {
            if (!rawData || rawData.length === 0) return;
            const val = timeSlider.value;
            const targetTime = sliderToTime(val);

            // rawData date is "YYYY-MM-DD HH:MM:SS" or similar
            // We want to find the record closest to targetTime
            const match = rawData.find(r => r.date.includes(targetTime));
            if (match && match.spot_price) {
                document.getElementById('spot-price-display').textContent = `Spot Price: ${match.spot_price}`;
            }
        }

        timeSlider.addEventListener('change', () => {
            if (!isLiveMode) {
                debouncedFetch(5000); // 5 sec delay after release
            }
        });

        // Date picker: max is YESTERDAY — today is reserved for Live mode only.
        const _today = new Date();
        const _yesterday = new Date(_today);
        _yesterday.setDate(_today.getDate() - 1);
        const todayStr = _today.toISOString().split('T')[0];
        const yesterdayStr = _yesterday.toISOString().split('T')[0];

        datePicker.max = todayStr;   // Allow today for auto-live redirection
        datePicker.value = yesterdayStr; // Default to yesterday as usual

        datePicker.addEventListener('change', () => {
            // Guard: reject FUTURE dates
            if (datePicker.value > todayStr) {
                alert("Future dates are not available.");
                datePicker.value = yesterdayStr;
                return;
            }

            // Redirect: If today is selected, switch to Live mode automatically
            if (datePicker.value === todayStr) {
                console.log("Today selected in picker. Redirecting to Live Mode...");
                const toggle = document.getElementById('live-toggle');
                if (!toggle.checked) {
                    toggle.checked = true;
                    toggleLiveMode();
                }
                return;
            }

            if (!isLiveMode) {
                debouncedFetch(100);
            }
        });

        const autoRefreshCb = document.getElementById('auto-refresh-cb');
        let refreshInterval = null;
        let isLiveMode = false;

        function isMarketOpen(prefix) {
            // Get current time in IST
            const now = new Date();
            const istTime = new Date(now.toLocaleString("en-US", { timeZone: "Asia/Kolkata" }));
            const day = istTime.getDay(); // 0=Sun, 6=Sat
            const hour = istTime.getHours();
            const min = istTime.getMinutes();
            const timeVal = hour * 100 + min;

            // Weekend Check
            if (day === 0 || day === 6) return false;

            if (prefix === 'NSE') {
                return (timeVal >= 915 && timeVal <= 1530);
            } else if (prefix === 'MCX') {
                return (timeVal >= 900 && timeVal <= 2330);
            }
            return false;
        }

        function toggleLiveMode() {
            const toggle = document.getElementById('live-toggle');
            const isLive = toggle.checked;
            const prefix = currentMode;
            // datePicker is already defined globally

            if (isLive) {
                if (!isMarketOpen(prefix)) {
                    alert(`Market is currently closed for ${prefix}. Live mode is only available during market hours (NSE: 09:15-15:30, MCX: 09:00-23:30, Mon-Fri IST).`);
                    toggle.checked = false;
                    isLiveMode = false;
                    return;
                }
                isLiveMode = true;
                datePicker.disabled = true;

                // Use local date for Today instead of UTC to avoid timezone mismatches
                const _now = new Date();
                const localToday = new Date(_now.getTime() - (_now.getTimezoneOffset() * 60000)).toISOString().split('T')[0];
                datePicker.value = localToday;

                // Force auto-refresh
                autoRefreshCb.checked = true;
                initWebSocket(); // Connect WebSocket
                startAutoRefresh(60000); // 1 minute polling fallback
                debouncedFetch(100);
            } else {
                isLiveMode = false;
                datePicker.disabled = false;

                // Reset to Yesterday when going OFF to avoid hitting the Today guard
                const _now = new Date();
                const yesterdayLocal = new Date(_now.getTime() - (_now.getTimezoneOffset() * 60000));
                yesterdayLocal.setDate(yesterdayLocal.getDate() - 1);
                const yesterdayStr = yesterdayLocal.toISOString().split('T')[0];
                datePicker.value = yesterdayStr;

                stopWebSocket(); // Disconnect WebSocket
                stopAutoRefresh();
                debouncedFetch(100); // Reload data for yesterday
            }
        }

        // autoRefreshCb.addEventListener('change', () => {
        //     if (autoRefreshCb.checked) {
        //         startAutoRefresh(isLiveMode ? 300000 : 60000);
        //     } else {
        //         stopAutoRefresh();
        //     }
        // });

        // WebSocket Integration
        let socket = null;

        function initWebSocket() {
            if (socket && socket.connected) return;

            try {
                socket = io();
                console.log("WebSocket connecting...");

                socket.on('connect', () => {
                    console.log("Connected to WebSocket");
                });

                socket.on('data_updated', (data) => {
                    console.log("Data switch detected via WebSocket:", data);
                    if (data.prefix === currentMode) {
                        console.log("Automatic reload triggered for", currentMode);
                        fetchData(true); // silent fetch
                    }
                });

                socket.on('disconnect', () => {
                    console.log("WebSocket disconnected");
                });
            } catch (e) {
                console.error("Failed to initialize WebSocket:", e);
            }
        }

        function stopWebSocket() {
            if (socket) {
                console.log("Closing WebSocket connection...");
                socket.disconnect();
                socket = null;
            }
        }

        function checkAutoRefresh() {
            // Logic removed for WebSocket implementation
        }

        let _autoRefreshInterval = null;
        function startAutoRefresh(ms = 60000) {
            stopAutoRefresh();
            console.log("Starting auto-refresh polling every", ms, "ms");
            _autoRefreshInterval = setInterval(() => {
                if (isLiveMode) {
                    console.log("Auto-refresh polling heartbeat...");
                    fetchData(true); // silent fetch
                }
            }, ms);
        }

        function stopAutoRefresh() {
            if (_autoRefreshInterval) {
                console.log("Stopping auto-refresh polling.");
                clearInterval(_autoRefreshInterval);
                _autoRefreshInterval = null;
            }
        }

        // Fetch data on load
        // datePicker.value is already set to yesterdayStr above — no need to re-compute
        if (!datePicker.value) datePicker.value = yesterdayStr;
        fetchData();
        document.getElementById('loading').style.display = 'none'; // Hide loading initially

        function fetchData(silent = false) {
            clearTimeout(_fetchDebounceTimer);
            const pending = document.getElementById('pending-indicator');
            if (pending) pending.style.display = 'none';

            const date = datePicker.value;
            if (!date) return;

            // Get time from slider
            const sliderVal = document.getElementById('time-slider').value;
            const time = sliderToTime(sliderVal);

            const updateBtn = document.querySelector('button[onclick="fetchData()"]');
            if (updateBtn) {
                updateBtn.disabled = true;
                updateBtn.textContent = "Updating Charts...";
            }

            if (!silent) {
                document.getElementById('loading').style.display = 'flex';
                let loadingText = `Loading ${currentMode} data for ${date}`;
                if (isLiveMode) loadingText = `Loading LIVE ${currentMode} data (Selected Date: ${date} overridden)`;
                else if (time) loadingText += ` at ${time}`;
                loadingText += `... (May take time if fetching new data)`;
                document.getElementById('loading').textContent = loadingText;
            }

            let url = `/api/option-data?date=${date}&symbol=${currentMode}`;
            // In non-live (historical/expired) mode, ALWAYS send the time from the slider.
            // sliderToTime() always returns a valid HH:MM string, so no need to guard.
            if (isLiveMode) {
                url += `&live=true`;
            } else {
                url += `&time=${time}`;   // always include time for historical/expired
            }

            fetch(url)
                .then(async response => {
                    let data = {};
                    const text = await response.text();
                    try {
                        data = JSON.parse(text);
                    } catch (e) {
                        throw new Error(`Invalid server response (not JSON)`);
                    }

                    if (!response.ok) {
                        // If it's a 404 or 500 but has an error message, throw it as an error object
                        throw new Error(data.error || `Server Error (${response.status})`);
                    }
                    return data;
                })
                .then(data => {
                    if (data.error) {
                        document.getElementById('loading').style.display = 'none';
                        if (!silent) {
                            alert(data.error);
                            if (data.error.includes("UPSTOX_ACCESS_TOKEN") || data.error.toLowerCase().includes("unauthorized")) {
                                document.getElementById('auth-error-container').style.display = 'block';
                            }
                        }

                        // If meta is present in error, display spot price at least
                        if (data.meta) {
                            if (data.meta.spot_price) {
                                document.getElementById('spot-price-display').textContent = `Spot Price: ${data.meta.spot_price}`;
                            }
                            if (data.meta.expired_contracts && !data.meta.has_data) {
                                document.getElementById('expiry-date-display').textContent = 'Archived Contracts Unavailable';
                                document.getElementById('expiry-date-display').style.color = 'red';
                            } else if (data.meta.expiry_date) {
                                document.getElementById('expiry-date-display').textContent = `Expiry: ${data.meta.expiry_date} (Archived)`;
                                document.getElementById('expiry-date-display').style.color = '#ff9800';
                            }
                        }
                        return;
                    } else {
                        document.getElementById('expiry-date-display').style.color = '#555';
                    }

                    // Handle new structure { data: [...], meta: {...} }
                    let records = [];
                    if (Array.isArray(data)) {
                        records = data; // Backward compatibility
                    } else if (data.data) {
                        records = data.data;
                        if (data.meta) {
                            if (data.meta.spot_price) {
                                document.getElementById('spot-price-display').textContent = `Spot Price: ${data.meta.spot_price}`;
                            }
                            if (data.meta.expiry_date) {
                                let label = data.meta.expired_contracts ? `Expiry: ${data.meta.expiry_date} (Archived)` : `Expiry: ${data.meta.expiry_date}`;
                                document.getElementById('expiry-date-display').textContent = label;
                                if (data.meta.expired_contracts) document.getElementById('expiry-date-display').style.color = '#ff9800';
                            } else {
                                document.getElementById('expiry-date-display').textContent = '';
                            }
                            if (data.meta.fetched_at) {
                                const fetchedTime = new Date(data.meta.fetched_at).toLocaleTimeString();
                                document.getElementById('last-updated').textContent = `Last Updated: ${fetchedTime}`;
                            }
                        } else {
                            document.getElementById('spot-price-display').textContent = '';
                            document.getElementById('expiry-date-display').textContent = '';
                            document.getElementById('last-updated').textContent = '';
                        }
                    }

                    rawData = records;
                    // Only re-init controls if not silent (or if structure changed significantly?)
                    // For live updates, we probably want to keep current selections.
                    // But if instruments change (e.g. new strikes added?), we might need to update list.
                    if (!silent) {
                        initializeControls(false); // full reset
                    } else {
                        updateControlsMerge(); // smart merge
                    }

                    updateDynamicSpotPrice(); // Update sidebar spot price from data
                    document.getElementById('loading').style.display = 'none';
                    renderCharts();
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                    document.getElementById('loading').style.display = 'none';
                    if (!silent) alert('Error loading data. Check console.');
                })
                .finally(() => {
                    if (updateBtn) {
                        updateBtn.disabled = false;
                        updateBtn.textContent = "Update Charts";
                    }
                });
        }

        function initializeControls() {
            const symbolSet = new Set(rawData.map(row => row.symbol));
            uniqueSymbols = Array.from(symbolSet).sort();

            const listContainer = document.getElementById('instrument-list');
            listContainer.innerHTML = '';

            uniqueSymbols.forEach(sym => {
                listContainer.appendChild(makeInstrumentRow(sym, true));
            });
        }

        function makeInstrumentRow(sym, checked) {
            const div = document.createElement('div');
            div.className = 'control-group';
            div.dataset.symbol = sym;
            div.innerHTML = `<label><input type="checkbox" class="instrument-cb" value="${sym}" ${checked ? 'checked' : ''}> ${sym}</label>`;
            return div;
        }

        function updateControlsMerge() {
            const newSymbols = new Set(rawData.map(row => row.symbol));
            const listContainer = document.getElementById('instrument-list');

            // Save current checkbox states
            const states = {};
            document.querySelectorAll('.instrument-cb').forEach(cb => {
                states[cb.value] = cb.checked;
            });

            // Remove rows for symbols no longer in data
            const existing = listContainer.querySelectorAll('[data-symbol]');
            existing.forEach(row => {
                if (!newSymbols.has(row.dataset.symbol)) {
                    row.remove();
                    console.log(`Removed strike: ${row.dataset.symbol}`);
                }
            });

            // Add rows for new symbols not yet in the list
            const existingSymbols = new Set(
                Array.from(listContainer.querySelectorAll('[data-symbol]')).map(r => r.dataset.symbol)
            );
            const sortedNew = Array.from(newSymbols).sort();
            sortedNew.forEach(sym => {
                if (!existingSymbols.has(sym)) {
                    // Insert in sorted order
                    const newRow = makeInstrumentRow(sym, true); // new strikes default checked
                    let inserted = false;
                    const rows = listContainer.querySelectorAll('[data-symbol]');
                    for (const row of rows) {
                        if (sym < row.dataset.symbol) {
                            listContainer.insertBefore(newRow, row);
                            inserted = true;
                            break;
                        }
                    }
                    if (!inserted) listContainer.appendChild(newRow);
                    console.log(`Added new strike: ${sym}`);
                }
            });

            // Restore previous checkbox states for unchanged symbols
            document.querySelectorAll('.instrument-cb').forEach(cb => {
                if (cb.value in states) cb.checked = states[cb.value];
            });

            uniqueSymbols = sortedNew;
        }

        function selectInstruments(type) {
            const checkboxes = document.querySelectorAll('.instrument-cb');
            checkboxes.forEach(cb => {
                if (type === 'all') cb.checked = true;
                else if (type === 'none') cb.checked = false;
                else if (type === 'ce') cb.checked = cb.value.includes('CE');
                else if (type === 'pe') cb.checked = cb.value.includes('PE');
            });
        }

        function renderCharts() {
            const chartsArea = document.getElementById('charts-area');
            chartsArea.innerHTML = '';

            // Get selected instruments
            const selectedInstruments = Array.from(document.querySelectorAll('.instrument-cb:checked')).map(cb => cb.value);

            // Get selected metrics
            const selectedMetrics = Array.from(document.querySelectorAll('.metric-cb:checked')).map(cb => cb.value);

            if (selectedInstruments.length === 0) {
                chartsArea.innerHTML = '<div style="text-align:center; color:#666;">No instruments selected.</div>';
                return;
            }

            if (selectedMetrics.length === 0) {
                chartsArea.innerHTML = '<div style="text-align:center; color:#666;">No metrics selected.</div>';
                return;
            }

            // Prepare data grouped by symbol
            const groupedData = {};

            rawData.forEach(row => {
                if (selectedInstruments.includes(row.symbol)) {
                    if (!groupedData[row.symbol]) {
                        groupedData[row.symbol] = { x: [], rowData: [] };
                    }
                    groupedData[row.symbol].x.push(row.date);
                    groupedData[row.symbol].rowData.push(row);
                }
            });

            // Generate a chart for EACH selected metric
            selectedMetrics.forEach(metric => {
                const chartDiv = document.createElement('div');
                chartDiv.className = 'chart-container';
                const chartId = `chart-${metric}`;
                chartDiv.innerHTML = `<div class="chart-header">${metricLabels[metric]}</div><div id="${chartId}"></div>`;
                chartsArea.appendChild(chartDiv);

                const traces = [];

                if (metric === 'spot_price') {
                    // For Spot Price, we only need ONE trace (the index) 
                    // since all symbols share the same spot_price data points
                    const firstSym = selectedInstruments[0];
                    if (groupedData[firstSym]) {
                        traces.push({
                            x: groupedData[firstSym].x,
                            y: groupedData[firstSym].rowData.map(r => r[metric]),
                            mode: 'lines',
                            name: currentMode === 'NSE' ? 'Nifty 50 Index' : 'Crude Oil Index',
                            line: {
                                width: 3,
                                color: '#007bff'
                            }
                        });
                    }
                } else {
                    selectedInstruments.forEach(symbol => {
                        if (!groupedData[symbol]) return;

                        const isCE = symbol.includes('CE');
                        const isPE = symbol.includes('PE');

                        // Dynamic Color Generation
                        // CE = Green hues, PE = Red hues
                        let color;
                        if (isCE) {
                            // Generate varied greens
                            // Use symbol hash to pick a stable variation
                            let hash = 0;
                            for (let i = 0; i < symbol.length; i++) {
                                hash = symbol.charCodeAt(i) + ((hash << 5) - hash);
                            }
                            const lightness = 25 + (Math.abs(hash) % 40); // 25% to 65% lightness
                            color = `hsl(120, 100%, ${lightness}%)`;
                        } else if (isPE) {
                            // Generate varied reds
                            let hash = 0;
                            for (let i = 0; i < symbol.length; i++) {
                                hash = symbol.charCodeAt(i) + ((hash << 5) - hash);
                            }
                            const lightness = 35 + (Math.abs(hash) % 30); // 35% to 65% lightness
                            color = `hsl(0, 100%, ${lightness}%)`;
                        } else {
                            color = '#888888';
                        }

                        traces.push({
                            x: groupedData[symbol].x,
                            y: groupedData[symbol].rowData.map(r => r[metric]),
                            mode: 'lines',
                            name: formatSymbol(symbol),
                            line: {
                                dash: isPE ? 'dash' : 'solid',
                                width: 2,
                                color: color
                            }
                        });
                    });
                }

                const layout = {
                    margin: { t: 20, r: 20, l: 50, b: 40 },
                    height: 400,
                    xaxis: { title: 'Time' },
                    yaxis: { title: metricLabels[metric] },
                    hovermode: 'x unified',
                    showlegend: true,
                    legend: { orientation: 'h', y: -0.2 }
                };

                Plotly.newPlot(chartId, traces, layout);
            });
        }

        function refreshToken() {
            const btn = document.querySelector('#auth-error-container button');
            const originalText = btn.textContent;
            btn.textContent = 'Refreshing...';
            btn.disabled = true;

            fetch('/api/refresh-token', { method: 'POST' })
                .then(r => r.json())
                .then(data => {
                    if (data.error) {
                        alert('Refresh failed: ' + data.error);
                        btn.textContent = originalText;
                        btn.disabled = false;
                    } else {
                        alert('Token refreshed! Retrying data fetch...');
                        document.getElementById('auth-error-container').style.display = 'none';
                        fetchData(); // Retry fetch
                    }
                })
                .catch(e => {
                    alert('Network error refreshing token');
                    btn.textContent = originalText;
                    btn.disabled = false;
                });
        }
    </script>
</body>

</html>