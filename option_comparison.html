
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Option Chain Visualizer</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .app-container {
            display: flex;
            flex: 1;
            height: 100%;
            overflow: hidden;
        }
        /* Sidebar Styles */
        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #e0e0e0;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.05);
        }
        .sidebar h2 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        /* Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 34px;
            height: 20px;
        }
        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider-toggle {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 34px;
        }
        .slider-toggle:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider-toggle {
            background-color: #2196F3;
        }
        input:focus + .slider-toggle {
            box-shadow: 0 0 1px #2196F3;
        }
        input:checked + .slider-toggle:before {
            -webkit-transform: translateX(14px);
            -ms-transform: translateX(14px);
            transform: translateX(14px);
        }
        .live-label {
            font-size: 12px;
            color: #666;
            margin-right: 5px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .control-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            cursor: pointer;
        }
        .scrollable-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 5px;
            border-radius: 4px;
        }
        .btn-group {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }
        .btn {
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .btn:hover {
            background: #e0e0e0;
        }
        
        /* Main Content Styles */
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .chart-container {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 400px;
        }
        .chart-header {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #444;
            border-left: 4px solid #007bff;
            padding-left: 10px;
        }
        
        /* Loading Overlay */
        #loading {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: #666;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading">Loading Option Data...</div>
    
    <div class="app-container">
        <!-- Sidebar Controls -->
        <div class="sidebar">
            <div>
                <h2>
                    Controls
                    <div style="display:flex; align-items:center;">
                        <span class="live-label">Live</span>
                        <label class="switch">
                            <input type="checkbox" id="live-toggle" onchange="toggleLiveMode()">
                            <span class="slider-toggle"></span>
                        </label>
                    </div>
                </h2>
                <div class="control-group">
                    <label for="date-picker">Select Date:</label>
                    <input type="date" id="date-picker" class="form-control" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <div class="control-group">
                    <label for="time-slider">Spot Reference Time: <span id="time-display" style="font-weight:bold; color:#007bff; margin-left:5px;">09:15</span></label>
                    <input type="range" id="time-slider" min="0" max="25" value="0" step="1" style="width: 100%;">
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666;">
                        <span>09:15</span>
                        <span>12:15</span>
                        <span>15:30</span>
                    </div>
                    <small style="color: #666; font-size: 11px;">Slide to change strike selection time</small>
                </div>
                <div class="control-group" id="auto-refresh-group" style="display:none; margin-top:5px;">
                     <label style="font-size: 12px; color: #666;">
                        <input type="checkbox" id="auto-refresh-cb"> Auto-Refresh (Live)
                     </label>
                </div>
                <div id="spot-price-display" style="margin-top: 10px; font-weight: bold; color: #007bff; font-size: 16px;"></div>
                <div id="expiry-date-display" style="font-size: 14px; color: #555; margin-top: 5px;"></div>
                <div id="last-updated" style="font-size: 10px; color: #999; margin-top: 2px;"></div>
            </div>

            <div>
                <h2>Instruments</h2>
                <div class="btn-group">
                    <button class="btn" onclick="selectInstruments('all')">All</button>
                    <button class="btn" onclick="selectInstruments('ce')">All CE</button>
                    <button class="btn" onclick="selectInstruments('pe')">All PE</button>
                    <button class="btn" onclick="selectInstruments('none')">Clear</button>
                </div>
                <div class="scrollable-list" id="instrument-list">
                    <!-- Checkboxes populated via JS -->
                </div>
            </div>

            <div>
                <h2>Metrics (Criteria)</h2>
                <div class="control-group" id="metric-list">
                    <label><input type="checkbox" class="metric-cb" value="ltp" checked> LTP</label>
                    <label><input type="checkbox" class="metric-cb" value="change_in_ltp"> Change in LTP</label>
                    <label><input type="checkbox" class="metric-cb" value="roc_oi" checked> ROC OI (%)</label>
                    <label><input type="checkbox" class="metric-cb" value="roc_volume"> ROC Volume (%)</label>
                    <label><input type="checkbox" class="metric-cb" value="roc_iv"> ROC IV (%)</label>
                    <label><input type="checkbox" class="metric-cb" value="coi_vol_ratio"> COI/Vol Ratio</label>
                    <label><input type="checkbox" class="metric-cb" value="spot_price"> Spot Price</label>
                </div>
            </div>

            <button class="btn" style="width: 100%; padding: 10px; background: #007bff; color: white; border: none;" onclick="renderCharts()">Update Charts</button>
        </div>

        <!-- Main Chart Area -->
        <div class="main-content" id="charts-area">
            <!-- Charts will be injected here -->
        </div>
    </div>

    <script>
        let rawData = [];
        let uniqueSymbols = [];

        const metricLabels = {
            'ltp': 'Last Traded Price',
            'change_in_ltp': 'Change in LTP',
            'roc_oi': 'Rate of Change in Open Interest (%)',
            'roc_volume': 'Rate of Change in Volume (%)',
            'roc_iv': 'Rate of Change in IV (%)',
            'coi_vol_ratio': 'Change in OI / Volume Ratio',
            'spot_price': 'Spot Price (Nifty 50)'
        };

        // Initialize Date Picker with today or default
        const datePicker = document.getElementById('date-picker');
        const timeSlider = document.getElementById('time-slider');
        const timeDisplay = document.getElementById('time-display');
        
        // Slider Logic
        function sliderToTime(val) {
            const startMinutes = 9 * 60 + 15; // 09:15 = 555
            const totalMinutes = startMinutes + (val * 15);
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        }

        timeSlider.addEventListener('input', () => {
            timeDisplay.textContent = sliderToTime(timeSlider.value);
        });

        timeSlider.addEventListener('change', () => {
            fetchData();
        });
        
        // Default to today if possible, or 2026-02-20
        const todayStr = new Date().toISOString().split('T')[0];
        // datePicker.value = todayStr; // Try setting to today
        
        // Prevent selecting today in date picker
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        const yesterdayStr = yesterday.toISOString().split('T')[0];
        datePicker.max = yesterdayStr;
        datePicker.value = yesterdayStr;

        // If today is not in data, maybe stick to 2026-02-20? 
        // Let's stick to the user's workflow. If they select a date, we use it.
        // But for initial load, let's try today.
        
        datePicker.addEventListener('change', () => {
            fetchData();
            checkAutoRefresh();
        });

        const autoRefreshCb = document.getElementById('auto-refresh-cb');
        let refreshInterval = null;
        let isLiveMode = false;

        function toggleLiveMode() {
            const toggle = document.getElementById('live-toggle');
            isLiveMode = toggle.checked;
            const datePicker = document.getElementById('date-picker');
            
            if (isLiveMode) {
                datePicker.disabled = true;
                const today = new Date().toISOString().split('T')[0];
                datePicker.value = today;
                
                // Force auto-refresh
                if (!autoRefreshCb.checked) {
                    autoRefreshCb.checked = true;
                }
                // 5 minutes = 300000 ms
                startAutoRefresh(300000);
                fetchData();
            } else {
                datePicker.disabled = false;
                stopAutoRefresh();
                checkAutoRefresh();
            }
        }

        autoRefreshCb.addEventListener('change', () => {
            if (autoRefreshCb.checked) {
                startAutoRefresh(isLiveMode ? 300000 : 60000);
            } else {
                stopAutoRefresh();
            }
        });

        function checkAutoRefresh() {
            const date = datePicker.value;
            const today = new Date().toISOString().split('T')[0];
            const refreshGroup = document.getElementById('auto-refresh-group');
            
            if (date === today) {
                refreshGroup.style.display = 'flex';
                // Auto-enable for today
                if (!autoRefreshCb.checked) {
                    autoRefreshCb.checked = true;
                    startAutoRefresh(isLiveMode ? 300000 : 60000);
                }
            } else {
                refreshGroup.style.display = 'none';
                stopAutoRefresh();
                autoRefreshCb.checked = false;
            }
        }

        function startAutoRefresh(interval = 60000) {
            if (refreshInterval) clearInterval(refreshInterval);
            refreshInterval = setInterval(() => {
                console.log("Auto-refreshing...");
                fetchData(true); // silent refresh
            }, interval);
        }

        function stopAutoRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
        }

        // Fetch data on load
        // checkAutoRefresh(); // Check if today matches
        // fetchData();
        document.getElementById('loading').style.display = 'none'; // Hide loading initially

        function fetchData(silent = false) {
            const date = datePicker.value;
            if (!date) return;
            
            // Get time from slider
            const sliderVal = document.getElementById('time-slider').value;
            const time = sliderToTime(sliderVal);

            if (!silent) {
                document.getElementById('loading').style.display = 'flex';
                let loadingText = `Loading data for ${date}`;
                if (time) loadingText += ` at ${time}`;
                loadingText += `... (May take time if fetching new data)`;
                document.getElementById('loading').textContent = loadingText;
            }

            let url = `/api/option-data?date=${date}`;
            if (time) url += `&time=${time}`;
            if (isLiveMode) url += `&live=true`;

            fetch(url)
                .then(response => {
                    if (!response.ok) throw new Error('Network response was not ok');
                    return response.json();
                })
                .then(data => {
                    if (data.error) {
                        document.getElementById('loading').style.display = 'none';
                        if (!silent) alert(data.error);
                        
                        // If meta is present in error, display spot price at least
                        if (data.meta) {
                             if (data.meta.spot_price) {
                                document.getElementById('spot-price-display').textContent = `Spot Price: ${data.meta.spot_price}`;
                             }
                             if (data.meta.expired_contracts) {
                                 document.getElementById('expiry-date-display').textContent = 'Expired Contracts Unavailable';
                                 document.getElementById('expiry-date-display').style.color = 'red';
                             } else {
                                 document.getElementById('expiry-date-display').textContent = '';
                             }
                        }
                        return;
                    } else {
                         document.getElementById('expiry-date-display').style.color = '#555';
                    }
                    
                    // Handle new structure { data: [...], meta: {...} }
                    let records = [];
                    if (Array.isArray(data)) {
                        records = data; // Backward compatibility
                    } else if (data.data) {
                        records = data.data;
                        if (data.meta) {
                             if (data.meta.spot_price) {
                                document.getElementById('spot-price-display').textContent = `Spot Price: ${data.meta.spot_price}`;
                             }
                             if (data.meta.expiry_date) {
                                document.getElementById('expiry-date-display').textContent = `Expiry: ${data.meta.expiry_date}`;
                             } else {
                                document.getElementById('expiry-date-display').textContent = '';
                             }
                             if (data.meta.fetched_at) {
                                 const fetchedTime = new Date(data.meta.fetched_at).toLocaleTimeString();
                                 document.getElementById('last-updated').textContent = `Last Updated: ${fetchedTime}`;
                             }
                        } else {
                             document.getElementById('spot-price-display').textContent = '';
                             document.getElementById('expiry-date-display').textContent = '';
                             document.getElementById('last-updated').textContent = '';
                        }
                    }

                    rawData = records;
                    // Only re-init controls if not silent (or if structure changed significantly?)
                    // For live updates, we probably want to keep current selections.
                    // But if instruments change (e.g. new strikes added?), we might need to update list.
                    // For now, let's NOT re-init controls on silent refresh to avoid resetting checkboxes.
                    if (!silent) {
                        initializeControls();
                    }
                    
                    document.getElementById('loading').style.display = 'none';
                    renderCharts();
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                    document.getElementById('loading').style.display = 'none';
                    if (!silent) alert('Error loading data. Check console.');
                });
        }

        function initializeControls() {
            // Extract unique symbols
            const symbolSet = new Set(rawData.map(row => row.symbol));
            uniqueSymbols = Array.from(symbolSet).sort();

            const listContainer = document.getElementById('instrument-list');
            listContainer.innerHTML = '';

            uniqueSymbols.forEach(sym => {
                const div = document.createElement('div');
                div.className = 'control-group';
                div.innerHTML = `
                    <label>
                        <input type="checkbox" class="instrument-cb" value="${sym}" checked>
                        ${sym}
                    </label>
                `;
                listContainer.appendChild(div);
            });
        }

        function selectInstruments(type) {
            const checkboxes = document.querySelectorAll('.instrument-cb');
            checkboxes.forEach(cb => {
                if (type === 'all') cb.checked = true;
                else if (type === 'none') cb.checked = false;
                else if (type === 'ce') cb.checked = cb.value.includes('CE');
                else if (type === 'pe') cb.checked = cb.value.includes('PE');
            });
            renderCharts();
        }

        function renderCharts() {
            const chartsArea = document.getElementById('charts-area');
            chartsArea.innerHTML = '';

            // Get selected instruments
            const selectedInstruments = Array.from(document.querySelectorAll('.instrument-cb:checked')).map(cb => cb.value);
            
            // Get selected metrics
            const selectedMetrics = Array.from(document.querySelectorAll('.metric-cb:checked')).map(cb => cb.value);

            if (selectedInstruments.length === 0) {
                chartsArea.innerHTML = '<div style="text-align:center; color:#666;">No instruments selected.</div>';
                return;
            }

            if (selectedMetrics.length === 0) {
                chartsArea.innerHTML = '<div style="text-align:center; color:#666;">No metrics selected.</div>';
                return;
            }

            // Prepare data grouped by symbol
            const groupedData = {};

            rawData.forEach(row => {
                if (selectedInstruments.includes(row.symbol)) {
                    if (!groupedData[row.symbol]) {
                        groupedData[row.symbol] = { x: [], rowData: [] };
                    }
                    groupedData[row.symbol].x.push(row.date);
                    groupedData[row.symbol].rowData.push(row);
                }
            });

            // Generate a chart for EACH selected metric
            selectedMetrics.forEach(metric => {
                const chartDiv = document.createElement('div');
                chartDiv.className = 'chart-container';
                const chartId = `chart-${metric}`;
                chartDiv.innerHTML = `<div class="chart-header">${metricLabels[metric]}</div><div id="${chartId}"></div>`;
                chartsArea.appendChild(chartDiv);

                const traces = [];

                selectedInstruments.forEach(symbol => {
                    if (!groupedData[symbol]) return;

                    const isCE = symbol.includes('CE');
                    const isPE = symbol.includes('PE');
                    
                    // Dynamic Color Generation
                    // CE = Green hues, PE = Red hues
                    let color;
                    if (isCE) {
                        // Generate varied greens
                        // Use symbol hash to pick a stable variation
                        let hash = 0;
                        for (let i = 0; i < symbol.length; i++) {
                            hash = symbol.charCodeAt(i) + ((hash << 5) - hash);
                        }
                        const lightness = 25 + (Math.abs(hash) % 40); // 25% to 65% lightness
                        color = `hsl(120, 100%, ${lightness}%)`;
                    } else if (isPE) {
                        // Generate varied reds
                        let hash = 0;
                        for (let i = 0; i < symbol.length; i++) {
                            hash = symbol.charCodeAt(i) + ((hash << 5) - hash);
                        }
                        const lightness = 35 + (Math.abs(hash) % 30); // 35% to 65% lightness
                        color = `hsl(0, 100%, ${lightness}%)`;
                    } else {
                        color = '#888888';
                    }

                    traces.push({
                        x: groupedData[symbol].x,
                        y: groupedData[symbol].rowData.map(r => r[metric]),
                        mode: 'lines',
                        name: symbol,
                        line: {
                            dash: isPE ? 'dash' : 'solid',
                            width: 2,
                            color: color
                        }
                    });
                });

                const layout = {
                    margin: { t: 20, r: 20, l: 50, b: 40 },
                    height: 400,
                    xaxis: { title: 'Time' },
                    yaxis: { title: metricLabels[metric] },
                    hovermode: 'x unified',
                    showlegend: true,
                    legend: { orientation: 'h', y: -0.2 }
                };

                Plotly.newPlot(chartId, traces, layout);
            });
        }
    </script>
</body>
</html>
